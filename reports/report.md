# 栈溢出攻击实验

姓名：刘梓昱

学号：2024200547

## 题目解决思路


### Problem 1: 
- **分析**：

  首先我们发现main函数后面有一个  40135d:	e8 d0 fe ff ff       	call   401232 <func>。这里调用了func，然后我们去看func，发现func里有明显的攻击区。sub分配栈空间，rbp-0x8是缓冲区，strcpy拷贝不检查长度。我们只需要跳转到func1即可，func1就是通关的函数。0x402004是答案的起始地址，调用put输出。我们用任意字符填满低16位，然后按照小端写入func1的地址即可。

  ![](img\3.png)
- **解决方案**：![](img\1.png)
- **结果**：![同上](img\2.png)

### Problem 2:
- **分析**：本题的攻击区明显也是func。缓冲区位rbp-0x8。func里调用了mencpy拷贝56个字节，显然会溢出。

  ![](img\6.png)

  我们发现答案位于40203b，因此本题不能只跳转到func2，还需要满足rdi=0x3f8才能跳转到下面的printf，然后才能打印处答案，也就是func2的参数必须为0x3f8。

  ![](img\5.png)

  我们发现汇编中有一个pop__rdi函数，因此先跳转到pop    %rdi，然后设置值为0x3f8，最后跳转到func2即可。

- **解决方案**：![payload是什么，即你的python代码or其他能体现你payload信息的代码/图片](img\7.png)

- **结果**：![附上图片](img\4.png)

### Problem 3: 
- **分析**：本题的func函数调用memcpy拷贝64字节，但是缓冲区位于rbp-0x20，因此第41-48字节会变成返回地址。我们需要跳转到func1，然后设置参数edi为72才能跳转到答案，但我们无法直接做到这一点。

  ![](img\13.png)

  因此我们需要先跳转到jmp_xs，jmp_xs会帮我们跳转到saved_rsp+0x10。saved_rsp是一个全局变量，储存一开始的rsp值。我们发现func开始的rsp-0x20正好就是缓冲区的起点。因此我们只需要在低40个字节的开头加入设置参数edi为72的指令即可。

  ![](img\14.png)

  我们编写一段设置edi为72然后跳转到func1的指令，转换成汇编放在缓冲区开头，然后把前40字节的后面部分用字符填满，最后加上jmp_xs的地址即可。

- **解决方案**：![payload是什么，即你的python代码or其他能体现你payload信息的代码/图片](img\12.png)

- **结果**：![附上图片](img\11.png)

### Problem 4: 
- **分析**：main程序运行开始先取出%fs:0x28，放到rbp-0x8的位置，用于后面检测有没有被修改。

  ![体现canary的保护机制是什么](img\9.png)

  func函数有检测保护的部分。如果不相同说明canary被修改，就跳转到__stack_chk_fail@plt，终止程序。

  ![](img\10.png)

- **解决方案**：无

- **结果**：![](img\8.png)

## 思考与总结

总体难度不大，但确实很有趣。

## 参考资料

无
